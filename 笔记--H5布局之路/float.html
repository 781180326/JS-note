<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>float</title>
	<style>
		.wrap { 
			width:400px;
			height:800px;
			box-shadow: 0 0 4px 4px #00f;
		}
		.left {
			float: left;
			width: 100px;
			background: #f00;
		}
		.left1{
			height: 130px;	
		}
		.left2{
			height: 300px;	
		}
		.left3{
			height: 300px;	
			width:110px;
		}
		.left4{
			width:90px;
			height: 120px;	
		}
		.left5{
			height:100px;
		}
		.right {
			float: right;
			width: 100px;
			height: 100px;
			box-shadow: 0 0 3px #00f;
			background: #0f0;
		}


		.float{
			float:left;
			width:100px;
			height:100px;
			background: #f00;
		}
		.nofloat{
			width:300px;
			height:200px;
			background: #0f0;
			z-index: 10000;
		}

		.one{
			display: inline-block;
			width:100px;
			height:100px;
			background: #0f0;
		}
		.middle{
			height:100px;
			background: #00f;
		}
		.two{
			float:right;
			width:100px;
			height:100px;
			background: #f00;
		}


		.d1,.d2,.d3{
			width:200px;
			height:200px;
			box-shadow:inset 0 0 1px 1px #0f0;
			text-align: center;
			line-height: 200px;
		}
		.d1{
			float:left;
		}
		.d2{
			clear:both;
			float:left;
		}
		.d3{
			float:right;
		}
	</style>
</head>
<body>
	<div class="wrap">
		<!-- <div class="left left1"></div>
		<div class="left left2"></div>
		<div class="left left3"></div>
		<div class="left left4"></div>
		<div class="right"></div>
				<div class="right"></div>

		<div class="right"></div>
		<div class="left left5"></div> -->


<!-- 		<div class="float"></div>
		<div class="nofloat"></div>
 -->		

		<!-- <div class="one"></div>
		<div class="middle"></div>
		<div class="two"></div> -->

		<div class="d1">1</div>
		<div class="d2">2</div>
		<div class="d3">3</div>
	</div>
</body>
</html>
<!--
	float总结：
		1、float:right的过程：
			(1)首先，忽略文档中的 ‘float:left和非块无浮动元素’ (也就是只保留 右浮动元素 和 display:block元素)；
			(2)然后，根据右浮动规则，从左下向上浮起(浮起时遇到块元素就会停止上浮，然后右浮)，再向右浮动，到达无干扰下在的右浮动位置
			(3)最后，查看当前所在位置是否有一部分或者全部被 ‘float:left或非块无浮动元素’ 占据，如果被占据，以1px为行高，换下一行继续从第(1)步重新开始
		2、float:left的过程和float:right同理，不过是忽略 ‘float:right和无浮动元素’,从右下->上浮->左浮动。。。
		3、不管是left还是right，都不能忽略无浮动普通文档流元素
		4、浮动元素相对于无浮动元素：
			脱离文档流、不占物理空间、相当于漂浮在普通文档流之上
		5、浮动元素必须考虑无浮动元素：
			①无浮动块元素在前、浮动元素在后：
				因为块元素默认占据一行，即使设置宽度很小，还是占据一行，打开浏览器，查看器盒模型，会发现自身宽度以外的位置被当做maigin外边距存在，所以其物理空间是占满一行的；
				在这种条件下，浮动元素只能漂浮在块元素下方，也就表现为换行浮动。
			②无浮动内联块inline-block元素在前、浮动元素在后：
				因为内联元素不会默认占据一行，所以为其设置宽度以后，本行其余空间不会被占据，所以，浮动元素就可以根据浮动规则判断是否可以浮动在本行。

			!!!!块元素存在时，对于浮动元素相当于一个挡板。
		6、无浮动元素会将浮动元素当做不存在：
			浮动元素在前，无浮动元素在后：
				浮动元素不占据空间，所以无浮动元素直接忽略浮动元素，认为浮动元素位置没有被占据，直接在无浮动位置排版。但是浮动元素总是在无浮动元素之上，不管无浮动元素设置多大的z-index，无浮动元素总是被遮盖。
		7、clear
			clear是用来清除浮动的，清除浮动有两个用处：
				1：清除对兄弟元素带来的影响
				2：清除对父级元素高度带来的影响
			清除浮动意思就是要将浮动的效果变为块的效果
			clear对于浮动元素：会将上一个兄弟元素视为块元素，下面的浮动元素都会在浮动时将其作为块元素对待。
-->