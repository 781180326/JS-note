类式继承
原型式继承
掺元类


示例：就地编辑
	类式继承：
	
		/*
		 * 参数： 
		 *	id   		将要创建的编辑域的id（方法里没有将id赋值给创建出来的containElement的id）,所以这个id是实例化对象的属性，并不是创建出来的标签的 id
		 *	parent   在哪个对象下面创建编辑域
		 *	value     初始化编辑域中的值
		 */
		function  EdiInPlaceField( id, parent, value){
				this.id = id;
				this.parentElement = parent;
				this.value = calue || "default value";
				
				this.createElements( this.id );
				this.attachEvents();
		};
		
		EdiInPlaceField.prototype = {
				createElements： function( id ){
						this.containerElement = document.createElement( 'div' );
						this.parentElement.appendChild( this.containerElement );
						
						this.staticElement = document.createElement( 'span' );
						this.staticElement.innerHTML = this.value;
						this.containerElement.appendChild( this.staticElement );
						
						this.fieldElement =  document.createElement( 'input' );
						this.fieldElement.type = 'text';
						this.fieldElement.value = this.value;
						this.containerElement.appendChild( this.fieldElement );
						
						this.saveButton = document.createElement( 'input' );
						this.saveButton.type = 'button';
						this.saveButton.value = 'Sava';
						this.containerElement.appendChild( this.saveButton );
						
						this.cancelButton = document.createElement( 'input' );
						this.cancelButton.type = 'button';
						this.cancelButton.value = 'Cancel';
						this.containerElement.appendChild( this.cancelButton );
						
						this.convertoText();
				},
				attachEvents: function( ){
						var that = this;
						addEvent( this.staticElement, 'click', function ( ) { that.convertToEditable(); } );
						addEvent( this.saveButton, 'click', function ( ) { that.save(); } );
						addEvent( this.cancelElement, 'click', function ( ) { that.cancel( ); } );
				},
				convertToEditable: function(){
						this.staticElement.style.display = 'none';
						this.fieldElement.style.display = 'inline';
						this.saveButton.style.display = 'inline';
						this.canselButton.style.display = 'inline';
						
						this.setValue( this.value );
				},
				save: function(){
						this.value = this.getValue();
						var that = this;
						var callback = {
								success: function(){ that.convertToText(); },
								failure: function(){ alert( 'error saving value.' };
						};
						ajaxRequest( 'GET', 'save.php?id=' + this.id + '&value=' +this.value, callback );
				},
				cancel: function(){
						this.convertToText();
				},
				convertToText: function(){
						this.staticElement.style.display = 'inline';
						this.fieldElement.style.display = 'none';
						this.saveButton.style.display = 'none';
						this.canselButton.style.display = 'none';
						
						this.setValue( this.value );
				},
				setValue: function( value ){
						this.fieldElement.value = value;
						this.staticElement.innerHTML = value;
				},
				getValue: function(){
						return this.fieldElement.value;
				}
				
		};
		
		
		
		//创建一个就地编辑域
		var titleClassical = new EdiInPlaceField( 'titleClassical', $('doc'), 'Title');
		var currentTitleText = titleClassical.getValue();
		
		
		
		用类式继承来创建一个多行文本框而不是单行文本框的类，使用继承
		 
		 function EditInPlaceArea( id, parent, value){
				EditInPlaceArea.superclass.constructor.call( this, id, parent, value);
		 };
		 extend( EditInPlaceArea, EditInPlaceField);
		 
		 EditInPlaceArea.prototype.createElements = function(){
				this.containerElement = document.createElement( 'div' );
				this.parentElement.appendChild( this.containerElement );
						
				this.staticElement = document.createElement( 'p' );
				this.staticElement.innerHTML = this.value;
				this.containerElement.appendChild( this.staticElement );
						
				this.fieldElement =  document.createElement( 'textarea' );
				this.fieldElement.value = this.value;
				this.containerElement.appendChild( this.fieldElement );
						
				this.saveButton = document.createElement( 'input' );
				this.saveButton.type = 'button';
				this.saveButton.value = 'Sava';
				this.containerElement.appendChild( this.saveButton );
						
				this.cancelButton = document.createElement( 'input' );
				this.cancelButton.type = 'button';
				this.cancelButton.value = 'Cancel';
				this.containerElement.appendChild( this.cancelButton );
						
				this.convertoText();
		 }
		 
		 EditInPlaceArea.prototype.convertToEditable = function(){
				this.staticElement.style.display = 'block';
				this.fieldElement.style.display = 'none';
				this.saveButton.style.display = 'none';
				this.canselButton.style.display = 'none';
						
				this.setValue( this.value );		
		 }
		
		 EditInPlaceArea.prototype.convertToText = function(){
				this.staticElement.style.display = 'none';
				this.fieldElement.style.display = 'block';
				this.saveButton.style.display = 'inline';
				this.canselButton.style.display = 'inline';
						
				this.setValue( this.value );		
		 }
		 
		 原型继承解决方案：
						嗯...没啥说的，就按原型继承来就行了。
		
		